package com.iksgmbh.sysnat.domain;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;

import com.iksgmbh.sysnat.domain.NaturalLanguagePatternPart.NaturalLanguagePatternPartType;
import com.iksgmbh.sysnat.exception.SysNatException.ErrorCode;
import com.iksgmbh.sysnat.utils.ExceptionHandlingUtil;

/**
 * Stores all information about a single natural language instruction read from a nltc file.
 * Each line of code in a ntlc file is supposed to represent a natural language instruction.
 * This line is parsed in this class into parts so that it can be compared with a NaturalLanguagePattern
 * in order to find matches.
 * 
 * @author Reik Oberrath
 */
public class LanguageInstructionPattern 
{
	public static final String[] PARAMETER_IDENTIFIER = { "\"", "|", "^" };
	public static final String RETURN_VALUE_IDENTIFIER = "'";

	/**
	 * Name of nltc file from which this instruction is read.
	 */
	private String fileName;
	private String instructionLine;
	private String returnValueName;
	
	private List<NaturalLanguagePatternPart> patternParts = new ArrayList<>();

	public LanguageInstructionPattern(final String nltcLine, 
			                          final String aFileName)
	{
		this.fileName = aFileName;
		this.instructionLine = nltcLine;
		
		final char[] charArray = nltcLine.toCharArray();
		final List<String> parameterIdentifier = Arrays.asList(PARAMETER_IDENTIFIER);
		
		String currentPart = "";
		boolean returnValueCandidateDetected = false;
		boolean parameterValueCandidateDetected = false;
		for (char c : charArray) 
		{
			if ( ! returnValueCandidateDetected && parameterIdentifier.contains("" + c)) 
			{
				if (parameterValueCandidateDetected) {
					addParameterPart(currentPart);
					currentPart = "";
					parameterValueCandidateDetected = false;
				} else {
					addDefaultPart(currentPart);
					currentPart = "";
					parameterValueCandidateDetected = true;
				}
			} else if (! parameterValueCandidateDetected && c == RETURN_VALUE_IDENTIFIER.charAt(0)) {
				if (returnValueCandidateDetected) 
				{
					addReturnValuePart(currentPart);
					currentPart = "";					
					returnValueCandidateDetected = false;
				} else {
					addDefaultPart(currentPart);
					currentPart = "";
					returnValueCandidateDetected = true;
				}
			} else {
				currentPart += c;
			}
		}
		
		if (parameterValueCandidateDetected) {
			ExceptionHandlingUtil.throwClassifiedException(ErrorCode.NATURAL_LANGUAGE_INSTRUCTING_PARSING__MISSING_CLOSING_PARAMETER_IDENTIFIER, 
					getFileName(), nltcLine);
		}
		
		if (returnValueCandidateDetected) {
			ExceptionHandlingUtil.throwClassifiedException(ErrorCode.NATURAL_LANGUAGE_INSTRUCTING_PARSING__MISSING_CLOSING_RETURN_VALUE_IDENTIFIER, 
					getFileName(), nltcLine);
		}
		
		addDefaultPart(currentPart);
		
		validate(getFileName(), nltcLine);
	}
	
	private void validate(String fileName, String nltcLine) 
	{
		int numberOfReturnValues = patternParts.stream()
				                   .filter(pp -> pp.type == NaturalLanguagePatternPartType.RETURN_VALUE)
				                   .collect(Collectors.toList()).size();
		
		if (numberOfReturnValues > 1) {
			ExceptionHandlingUtil.throwClassifiedException(ErrorCode.NATURAL_LANGUAGE_INSTRUCTING_PARSING__DOUBLE_RETURN_VALUE_IDENTIFIER, 
					fileName, nltcLine);
		}
		
	}

	private void addDefaultPart(String text) 
	{
		if (text != null && ! text.isEmpty()) {
			patternParts.add(new NaturalLanguagePatternPart(NaturalLanguagePatternPartType.DEFAULT, text));
		}
	}

	private void addParameterPart(String aParameterName) 
	{
		if (aParameterName == null || aParameterName.trim().length() == 0) {
			ExceptionHandlingUtil.throwClassifiedException(
					ErrorCode.NATURAL_LANGUAGE_INSTRUCTING_PARSING__EMPTY_PARAMETER_IDENTIFIER, 
					getOrigin());
		}
		patternParts.add(new NaturalLanguagePatternPart(NaturalLanguagePatternPartType.PARAMETER, aParameterName));
	}

	private void addReturnValuePart(String aReturnValueName) 
	{
		if (aReturnValueName == null || aReturnValueName.trim().length() == 0) {
			ExceptionHandlingUtil.throwClassifiedException(
					ErrorCode.NATURAL_LANGUAGE_INSTRUCTING_PARSING__EMPTY_RETURN_VALUE_IDENTIFIER, 
					getOrigin());
		}
		patternParts.add(new NaturalLanguagePatternPart(NaturalLanguagePatternPartType.RETURN_VALUE, aReturnValueName));
		this.returnValueName = aReturnValueName;
	}

	public String getFileName() {
		return fileName;
	}

	public String getReturnValueName() {
		return returnValueName;
	}

	public int getNumberOfParts() {
		return patternParts.size();
	}

	public NaturalLanguagePatternPart getPart(int i) {
		return patternParts.get(i);
	}
	
	@Override
	public String toString() {
		return instructionLine;
	}
	
	public String getOrigin() {
		return fileName + "-" + instructionLine; 
	}
}
